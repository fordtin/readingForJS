# <a href="javascript:void(0);" id="top">编程适用技巧</a>
[TOC]
[]: <>(http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/)
## 一、弹性
非常常用的的组件Tab选项卡为例，从粗糙到精致的转变。Tab和UI是紧密关联的，（Drag和Rize与具体UI无关）。
### 1.1 开始编写Tab组件
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-66 开始编写Tab组件.html">开始编写Tab组件</a>
```
// 开始编写Tab组件 代码清单5-66
// index.css
ul {
    padding: 0; 
    margin: 0;
}
.tab {
    width: 400px;
}
.tab-menuWrapper {
    padding-left: -20px;
}
.tab-menuWrapper li { 
    float: left; 
    display: inline; 
    padding: 5px; 
    border: 1px solid #333; 
    border-bottom: none; 
    margin-right: 5px; 
}
.tab-contentWrapper {
    border: 1px solid #333; 
    clear: left; 
    padding: 5px;
}



<div class="tab">
    <ul class="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
        <li>menu3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div>content1</div>
        <div style="display: none;" >content2</div>
        <div style="display: none;" >content3</div>
    </div>
</div>

```

### 1.2 让HTML标签挂上id
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-67 让HTML标签挂上id.html">让HTML标签挂上id</a>
```
// 让HTML标签挂上id 代码清单5-67
// index.css

<div class="tab">
    <ul class="tab-menuWrapper">
        <li id="tab-menu1">menu1</li>
        <li id="tab-menu2">menu2</li>
        <li id="tab-menu3">menu3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div id="tab-content1">content1</div>
        <div id="tab-content2" style="display: none;" >content2</div>
        <div id="tab-content3" style="display: none;" >content3</div>
    </div>
</div>

// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenu1 = document.getElementById('tab-menu1'),
    tabMenu2 = document.getElementById('tab-menu2'),
    tabMenu3 = document.getElementById('tab-menu3'),
    tabContent1 = document.getElementById('tab-content1'),
    tabContent2 = document.getElementById('tab-content2'),
    tabContent3 = document.getElementById('tab-content3');
// 让tabMenu监听click事件
tabMenu1.onclick = function() {
    tabContent1.style.display = 'block';
    tabContent2.style.display = 'none';
    tabContent3.style.display = 'none';
};
tabMenu2.onclick = function() {
    tabContent1.style.display = 'none';
    tabContent2.style.display = 'block';
    tabContent3.style.display = 'none';
};
tabMenu3.onclick = function() {
    tabContent1.style.display = 'none';
    tabContent2.style.display = 'none';
    tabContent3.style.display = 'block';
};

```


现在工作正常，但如果客户（或老板、产品经理）要求Tab有4个标签呢？
手动添加tab-menu4、tab-content4之前，客户说还需要增加2个标签，共6个标签。
这样，就需要做大量重复工作。有没有更好的方法呢？——————让标签数量自适应，不管是添加几个都无需修改JavaScript，只简单修改HTML。
现在数组是时候上场了！
将menu和content的DOM节点都存入数组，再对数组变量来绑定监听器。
问题变成如何批量获取DOM节点？除getElementById之外，可用getElementsByTagName来获得DOM节点。
### 1.3 提高Tab扩展性
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-68 提高Tab扩展性.html">提高Tab扩展性</a>
```
// 提高Tab扩展性 代码清单5-68
// index.css

<div class="tab">
    <ul class="tab-menuWrapper" id="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
        <li>menu3</li>
        <li>menu4</li>
    </ul>
    <div class="tab-contentWrapper" id="tab-contentWrapper">
        <div>content1</div>
        <div style="display: none;" >content2</div>
        <div style="display: none;" >content3</div>
        <div style="display: none;" >content4</div>
    </div>
</div>

<script>
// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = document.getElementById('tab-menuWrapper').getElementsByTagName('li'),
    tabContents = document.getElementById('tab-contentWrapper').getElementsByTagName('div');
//遍历数组，让 tabMenu 监听 click 事件
for(var i = 0; i < tabMenus.length; i++) {
    tabMenus[i].onclick = function() {
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[i].style.display = 'block';
    }
}

</script>
```
修改后程序更精简了，刷新页面，没有正常工作。
点击后所有content都隐藏了，报错：'tabContents[i] is undefined'

这是JavaScript一个经典问题：遍历数组时对DOM监听事件，索引值始终等于遍历结束后的值。
### 1.4 循环中的i
简单测试一下：
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-69 循环中的i.html">循环中的i</a>
```
// 循环中的i 代码清单5-69

for(var i = 0; i < tabMenus.length; i++) {
    tabMenus[i].onclick = function() {
        alert(i); // 4 4 4 4
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[i].style.display = 'block';
    }
}
```
不会弹出0、1、2、3，而是4、4、4、4。
这样无论点击什么都会设置显示‘block’
解决方法有两个：一、利用闭包；二、给DOM节点添加_index属性，属性值等于索引。
### 1.5 解决循环Bug
#### 1.5.1 解决循环Bug————方法一
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-70.html">解决循环Bug————方法一</a>
```
//  解决循环Bug————方法一  代码清单5-70 

// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = document.getElementById('tab-menuWrapper').getElementsByTagName('li'),
    tabContents = document.getElementById('tab-contentWrapper').getElementsByTagName('div');
//遍历数组，让 tabMenu 监听 click 事件

for(var i = 0; i < tabMenus.length; i++) {
    (function(_i) {
        tabMenus[_i].onclick = function() {
            console.log(_i); // 点击4个按钮分别0、1 、2 、3
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[_i].style.display = 'block';
        }
    })(i);
}
```
#### 1.5.2 解决循环Bug————方法二
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-71 解决循环Bug————方法二.html">解决循环Bug————方法二</a>

```
//  解决循环Bug————方法二  代码清单5-71
// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = document.getElementById('tab-menuWrapper').getElementsByTagName('li'),
    tabContents = document.getElementById('tab-contentWrapper').getElementsByTagName('div');
//遍历数组，让 tabMenu 监听 click 事件
for(var i = 0; i < tabMenus.length; i++) {
    tabMenus[i]._index = i;
    tabMenus[i].onclick = function() {
        console.log(this._index); // 分别点击4个按钮分别是 0、1 、2 、3
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[this._index].style.display = 'block';
    }
}

```
默认情况下DOM对象有innerHTML、tagName等属性，还可给DOM对象添加自定义属性，此处_index就是为DOM节点添加的自定义属性。
现在无论需要多少个标签，只需要修改相应的HTML标签，而无需修改JavaScript。
如下：
#### 1.5.3  2个标签的Tab
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-72 2个标签的Tab.html">2个标签的Tab</a>

```
//  2个标签的Tab  代码清单5-72
// index.css

<div class="tab">
    <ul class="tab-menuWrapper" id="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
    </ul>
    <div class="tab-contentWrapper" id="tab-contentWrapper">
        <div>content1</div>
        <div style="display: none;" >content2</div>
    </div>
</div>

```
#### 1.5.4  5个标签的Tab
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-73 5个标签的Tab.html">5个标签的Tab</a>

```
//  5个标签的Tab  代码清单5-73
// index.css

<div class="tab">
    <ul class="tab-menuWrapper" id="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
        <li>menu3</li>
        <li>menu4</li>
        <li>menu5</li>
    </ul>
    <div class="tab-contentWrapper" id="tab-contentWrapper">
        <div>content1</div>
        <div style="display: none;" >content2</div>
        <div style="display: none;" >content3</div>
        <div style="display: none;" >content4</div>
        <div style="display: none;" >content5</div>
    </div>
</div>
```
现在仍然存在一个很严重的问题：现在content还只是简单的结构，真实环境中可能是复杂的HTML片段
### 1.6 结构稍复杂的Tab
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-74 结构稍复杂的Tab.html">结构稍复杂的Tab </a>

```
//  结构稍复杂的Tab  代码清单5-74
// index.css

<div class="tab">
    <ul class="tab-menuWrapper" id="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
        <li>menu3</li>
    </ul>
    <div class="tab-contentWrapper" id="tab-contentWrapper">
        <div><div>content1 <ul><li>abc</li></ul></div></div>
        <div style="display: none;" ><p>content2</p><div>abc</div></div>
        <div style="display: none;" >content3</div>
    </div>
</div>
```
content里还包含div标签，document.getElementById('tab-contentWrapper').getElementsByTagName('div')返回的就不再是单纯的content组成的数组，也包含content内部的div

### 1.7 复杂结构带来的问题
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-75 复杂结构带来的问题.html">复杂结构带来的问题 code5-75</a>
```
//  复杂结构带来的问题  代码清单5-75
// index.css

<div class="tab">
    <ul class="tab-menuWrapper" id="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
        <li>menu3</li>
    </ul>
    <div class="tab-contentWrapper" id="tab-contentWrapper">
        <div><div>content1 <ul><li>abc</li></ul></div></div>
        <div style="display: none;" ><p>content2</p><div>abc</div></div>
        <div style="display: none;" >content3</div>
    </div>
</div>


// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = document.getElementById('tab-menuWrapper').getElementsByTagName('li'),
    tabContents = document.getElementById('tab-contentWrapper').getElementsByTagName('div');
alert(tabContents.length); // 5

```
alert(tabContents.length); // 5，不是3！！！
需要一个方法，可不依赖tagName来得到DOM对象组成数组。——————需要getElementsByClassName

## 二、getElementById、getElementsByTagName和getElementsByClassName
<a href="#top" style="font-size: 30px; font-weight: 700; color: #ff0000;">返回顶部</a>
getElementsByTagName：要求父容器内部结构必须非常稳定，一旦父容器内部结构HTML发生变化，很可能通过getElementsByTagName获得的DOM节点就会跟着改变，产生意料之外的错误。
原生并不支持getElementsByClassName，需要自己定义一个。
### 2.1 使用getElementsByClassName
注：为了区别**class是用于CSS的挂钩还是JavaScript的挂钩**（方便后期维护），我们可以给用于JavaScript的class加上“J_”作为前缀。

**Tab的menu部分HTML结构非常稳定，所以可使用getElementsByTagName，但content部分的HTML结构就充满未知，我们只能使用getElementsByClassName**

<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-76 使用getElementsByClassName.html">复杂结构带来的问题</a>

```
//  使用getElementsByClassName  代码清单5-76
// index.css

<div class="tab">
    <ul class="tab-menuWrapper" id="tab-menuWrapper">
        <li>menu1</li>
        <li>menu2</li>
        <li>menu3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content3</div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  


// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = document.getElementById('tab-menuWrapper').getElementsByTagName('li'),
    tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content');
//遍历数组，让 tabMenu 监听 click 事件
for(var i = 0; i < tabMenus.length; i++) {
    tabMenus[i]._index = i;
    tabMenus[i].onclick = function() {
        console.log(tabContents.length); // 3
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[this._index].style.display = 'block';
    }
}
```
现在达到要求了，但不要过早高兴，现在
客户要求：这个页面需要3个Tab，另外一个页面需要5个Tab。


## 三、可复用性（多个Tab）

我们的Tab能够满足复用条件吗？
不能：因为Tab的menu部分使用了id作为挂钩——tab-menuWrapper。同一个页面id只能出现一次，所以程序需要被多处复用，就一定不能使用id作为JavaScript获得DOM节点的挂钩
不能的话，现在该怎么办？
### 3.1 将id换为class
去掉id，改用class作为挂钩
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-77 将id换为class.html">复杂结构带来的问题</a>

```
//  将id换为class  代码清单5-77
// index.css

<div class="tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1</li>
        <li class="J_tab-menu">menu2</li>
        <li class="J_tab-menu">menu3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content3</div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  


// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu'),
    tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content');
//遍历数组，让 tabMenu 监听 click 事件
for(var i = 0; i < tabMenus.length; i++) {
    tabMenus[i]._index = i;
    tabMenus[i].onclick = function() {
        console.log(tabContents.length); // 3
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[this._index].style.display = 'block';
    }
}

```
程序工作很顺利，接着在页面中继续写2个Tab，点击出现问题了
### 3.2 3个Tab
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-78 3个Tab.html">3个Tab</a>
```
//  3个Tab  代码清单5-78
// index.css

 <!-- 第一个选项卡 -->
<div class="tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  


// 获得tabMenu和tabContent的DOM节点，并保存在变量中
var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu'),
    tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content');
//遍历数组，让 tabMenu 监听 click 事件
for(var i = 0; i < tabMenus.length; i++) {
    tabMenus[i]._index = i;
    tabMenus[i].onclick = function() {
        console.log(tabContents.length); // 3
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[this._index].style.display = 'block';
    }
}


```
当我们点击某人标签时，不仅当前的Tab中其它content隐藏了，另外两个Tab的content也隐藏了。
### 3.3 给Tab添加根节点挂钩
程序没有区分menu和content从属于哪个Tab。需要个menu和content指定从属于哪个Tab，
即通过getElementsByClassName指定父容器，从而将3个Tab分开。即组件需要指定一个根节点，以保持各个组件之间的独立性。——————J_tab
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-79 给Tab添加根节点挂钩.html">给Tab添加根节点挂钩</a>
```
//  给Tab添加根节点挂钩  代码清单5-79
// index.css

 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>



var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  


function setTab(root) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            console.log(tabContents.length); // 5
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';
        }
    }
}
var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
for(var i = 0; i < tabs.length; i++) {
    setTab(tabs[i]);
}

```

## 四、避免产生副作用
<a href="#top" style="font-size: 30px; font-weight: 700; color: #ff0000;">返回顶部</a>
### 4.1 高亮当前Tab
客户又有新需求了，让当前Tab能够高亮显示，样式用灰底白字
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-80 高亮当前Tab.html">高亮当前Tab</a>
```
//  高亮当前Tab  代码清单5-80
// 以下默认都为index2.css（index.css新增.tab .tab-currentMenu）
.tab .tab-currentMenu {background-color: #333; color: #fff; }


 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>




var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  


function setTab(root) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName('tab-currentMenu', root)[0];
            if(currentMenu) {
                currentMenu.className = '';
            }
            this.className = 'tab-currentMenu'; //给当前被点击的按钮挂上当前选中的 class
        }
    }
}
var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
for(var i = 0; i < tabs.length; i++) {
    setTab(tabs[i]);
}

```
### 4.2 修改className
程序虽然能正常工作，但有个地方需要我们注意，如下：

```
//  修改className  代码清单5-81

if(currentMenu) {
    currentMenu.className = '';
}
this.className = 'tab-currentMenu'; //

```
给当前被点击的按钮挂上当前选中的 class
上面代码本意是添加和删除“tab-currentMenu”这个用于标识当前状态的class，如果DOM节点没有包含其它用于挂接样式的class（用于监听事件的不算）就不会出现意外，但如果DOM节点挂接了其它用于样式的class，就会出现冲突了！


### 4.3 修改className引起的冲突
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-82 修改className引起的冲突.html">修改className引起的冲突</a>

```
//  修改className引起的冲突  代码清单5-82
// 以下默认都为index3.css（index2.css上新增.underline）
.tab .tab-currentMenu {background-color: #333; color: #fff; }
.underline {text-decoration: underline;}

<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>




var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  


function setTab(root) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName('tab-currentMenu', root)[0];
            if(currentMenu) {
                currentMenu.className = '';
            }
            this.className = 'tab-currentMenu'; //给当前被点击的按钮挂上当前选中的 class
        }
    }
}
var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
for(var i = 0; i < tabs.length; i++) {
    setTab(tabs[i]);
}
```

### 4.4 修改至无副作用
新增class “underline”
初始时，menu1-3有下划线，点击menu1-3之后，下划线会消失，这不是我们想要的结果，即Tab产生了副作用。
我们需要的是添加和删除tab-currentMenu，而不是设置class为tab-currentMenu和清空所有class。
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-83 修改至无副作用.html">修改至无副作用</a>

```
//  修改至无副作用  代码清单5-83

if(currentMenu) {
    currentMenu.className = currentMenu.className.replace(new RegExp("(^|\\s+)tab-currentMenu"), '');
}
if(!new RegExp("(^|\\s+)tab-currentMenu").test(this.className)) {
    this.className = this.className + ' tab-currentMenu'; //给当前被点击的按钮挂上当前选中的 class
}
```
### 4.5 定义addClass和removeClass函数
考虑到这种添加和删除class的操作在其他地方也会有可能被使用，可在GLOBAL.Dom这个明明空间下，新增两个base层的接口：addClass(node, str)、removeClass(node, str)。代码如下：

<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-84 定义addClass和removeClass函数.html">定义addClass和removeClass函数</a>
```
//  定义addClass和removeClass函数  代码清单5-84

// 添加class
GLOBAL.Dom.addClass = function(node, str) {
    if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
        node.className = node.className + ' ' + str;
    }
};
// 移除class
GLOBAL.Dom.removeClass = function(node, str) {
    node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
};
...
if(currentMenu) {
    GLOBAL.Dom.removeClass(currentMenu, 'tab-currentMenu');
}
GLOBAL.Dom.addClass(this, 'tab-currentMenu');

```



## 五、通过传参实现定制
### 5.1 编写setTab2和setTab3
客户又提出：这个高亮效果不错，但改变为：第一个Tab的当前标签不加高亮，第二个Tab的当前标签需要高亮，第三个Tab也许要高亮，同时与第二个Tab的高亮样式有所区别
应对措施：复制setTab函数，编写setTab2和setTab3
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-85 编写setTab2和setTab3.html">编写setTab2和setTab3</a>

```
//  编写setTab2和setTab3  代码清单5-85
...//即index4.css
.tab .tab-currentMenu {background-color: #333; color: #fff; }
.tab .tab-currentMenu2 {background-color: #0000ff; color: #fff; }
.underline {text-decoration: underline;}



 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu2">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  
GLOBAL.Dom.addClass = function(node, str) {
    if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
        node.className = node.className + ' ' + str;
    }
};
GLOBAL.Dom.removeClass = function(node, str) {
    node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
};


function setTab(root) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';
            /*
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName('tab-currentMenu', root)[0];
            if(currentMenu) {
                GLOBAL.Dom.removeClass(currentMenu, 'tab-currentMenu');
            }
            GLOBAL.Dom.addClass(this, 'tab-currentMenu');
            */
        }
    }
}

//当前标签挂上高亮样式1
function setTab2(root) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName('tab-currentMenu', root)[0];
            if(currentMenu) {
                // currentMenu.className = currentMenu.className.replace(new RegExp("(^|\\s+)tab-currentMenu"), '');
                GLOBAL.Dom.removeClass(currentMenu, 'tab-currentMenu');
            }
        /*  if(!new RegExp("(^|\\s+)tab-currentMenu").test(this.className)) {
                this.className = this.className + ' tab-currentMenu'; //给当前被点击的按钮挂上当前选中的 class
            }*/
            GLOBAL.Dom.addClass(this, 'tab-currentMenu');
        }
    }
}

//当前标签挂上高亮样式2
function setTab3(root) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName('tab-currentMenu2', root)[0];
            if(currentMenu) {
                // currentMenu.className = currentMenu.className.replace(new RegExp("(^|\\s+)tab-currentMenu"), '');
                GLOBAL.Dom.removeClass(currentMenu, 'tab-currentMenu2');
            }
        /*  if(!new RegExp("(^|\\s+)tab-currentMenu").test(this.className)) {
                this.className = this.className + ' tab-currentMenu'; //给当前被点击的按钮挂上当前选中的 class
            }*/
            GLOBAL.Dom.addClass(this, 'tab-currentMenu2');
        }
    }
}

var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
setTab(tabs[0]);
setTab2(tabs[1]);
setTab3(tabs[2]);

```
但是不够好：
1. setTab、setTab2、setTab3代码大部分相同，可以考虑重用它们
2. 扩展性糟糕，如果以后还要添加绿底白字或者红底白字的高亮样式，有需要添加setTab4、setTab5。因为setTab、setTab2、setTab3之间的区别仅仅是给当前标签挂上不同的class（或者不挂class），二setTab、setTab2、setTab3都将class名“写死”在函数内部，所以无法重用

### 5.2 用参数写活变化的部分

我们可以将这个容易变化的因素从函数内部分离，以参数的形式传进来，函数内部引用这个参数，从而将class名“写活”。代码如下：
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-86 用参数写活变化的部分.html">用参数写活变化的部分</a>
```
//  用参数写活变化的部分  代码清单5-86
//index4.css

 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu2">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
GLOBAL.namespace("Dom");
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = typeof root == 'string' ? document.getElementById(root) : root;
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  
// 添加class
GLOBAL.Dom.addClass = function(node, str) {
    if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
        node.className = node.className + ' ' + str;
    }
};
// 移除class
GLOBAL.Dom.removeClass = function(node, str) {
    node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
};


function setTab(root, currentClass) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
    

    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;
        tabMenus[i].onclick = function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';

            // 设置样式
            if(currentClass) {
                var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
                if(currentMenu) {
                    GLOBAL.Dom.removeClass(currentMenu, currentClass);
                }
                GLOBAL.Dom.addClass(this, currentClass);
            }
        }
    }
}

var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
setTab(tabs[0]);
setTab(tabs[1], 'tab-currentMenu');
setTab(tabs[2], 'tab-currentMenu2');
```
即一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦

### 5.3 写活事件触发方式

除了当前高亮样式可以通过传参定制，另一个经常需要定制的是标签的激活事件
本例中，激活标签是通过click事件，但标签还有另一种常见的激活方式mouseover。我们最好将标签激活条件也写活，可以通过一个参数轻易实现定制。
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-87 写活事件触发方式.html">写活事件触发方式</a>
```
//  写活事件触发方式  代码清单5-87

 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu2">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>



var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
// 与DOM相关
GLOBAL.namespace("Dom");
GLOBAL.Dom.get = function(node) {
    node = typeof node === 'string' ? document.getElementById(node) : node;
    return node;
};
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = GLOBAL.Dom.get(root);
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  
// 添加class
GLOBAL.Dom.addClass = function(node, str) {
    if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
        node.className = node.className + ' ' + str;
    }
};
// 移除class
GLOBAL.Dom.removeClass = function(node, str) {
    node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
};

// 与Event相关
GLOBAL.namespace('Event');
// 添加事件（或者说监听事件）
GLOBAL.Event.addHandler = function(node, eventType, handler) {
    node = GLOBAL.Dom.get(node);
    if(node.addEventListener) {
        node.addEventListener(eventType, handler, false);
    }
    else if(node.attachEvent) {
        node.attachEvent('on' + eventType, handler);
    }
    else {
        node['on' + eventType] = handler;
    }
};



function setTab(root, currentClass, trigger) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
        // 如果不传入激活类型，默认激活类型为点击
        trigger = trigger || "click";

    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;

        GLOBAL.Event.addHandler(tabMenus[i], trigger, function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            tabContents[this._index].style.display = 'block';

            // 设置样式
            if(currentClass) {
                var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
                if(currentMenu) {
                    GLOBAL.Dom.removeClass(currentMenu, currentClass);
                }
                GLOBAL.Dom.addClass(this, currentClass);
            }
        });
    }
}
var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
setTab(tabs[0], null, 'mouseover');
setTab(tabs[1], 'tab-currentMenu');
setTab(tabs[2], 'tab-currentMenu2', 'mouseover');

```

运行上述代码：
IE8-报错：无法获取未定义或 null 引用的属性“style” this.index弹出“undefined”。
this关键字的指向？IE下this指向window

## 六、控制this关键字的指向
<a href="#top" style="font-size: 30px; font-weight: 700; color: #ff0000;">返回顶部</a>
### 6.1 调试Bug
‘tabContents[...].style'为空或不是对象，alert(this._index)，IE下弹出undefined。

```
//  调试Bug  代码清单5-88

GLOBAL.Event.addHandler(tabMenus[i], trigger, function() {
    for(var j = 0; j < tabContents.length; j++) {
        tabContents[j].style.display = 'none';
    }
    alert(this._index);
    tabContents[this._index].style.display = 'block';
});
```
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-88 写活事件触发方式.html">写活事件触发方式</a>
alert(this._index); // IE8-: undefined.

this关键字的指向？IE下this指向window


### 6.2 this指针
#### 6.2.1 JavaScript伪协议和内联事件
#### 6.2.2 setTimeout和setInterval改变this指向
#### 6.2.3 onxxxx改变this指向
JavaScript中this指针是个让人捉摸不定的东西。

1.如JavaScript伪协议和内联事件对于this的指向不同 
2.setTimeout和setInterval也会改变this的指向
3."Dom.onxxx"也会改变this的指向

<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-89 JavaScript伪协议和内联事件.html">JavaScript伪协议和内联事件</a>
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-90 setTimeout和setInterval改变this指向.html">setTimeout和setInterval改变this指向</a>

```
//  JavaScript伪协议和内联事件  代码清单5-89
<!-- A -->
<a href="#" onclick="alert(this.tagName)">click me</a><br/>
<!-- undefined -->
<a href="JavaScript:alert(this.tagName)">click me</a><br/>
<!-- true -->
<a href="JavaScript:alert(this == window)">click me</a><br/>



//  setTimeout和setInterval改变this指向  代码清单5-90
var name = 'somebody';
var leo = {
    name: 'leo',
    say: function() {
        alert("I'm " + this.name);
    }
};
leo.say(); // I'm leo
setTimeout(leo.say, 1000); // I'm somebody
setInterval(leo.say, 1000); // I'm somebody


//  onxxxx改变this指向  代码清单5-91
<input type="button" value="click me" id="btn" name="BUTTON" />

var name = 'somebody';
var leo = {
    name: 'leo',
    say: function() {
        alert("I'm " + this.name);
    }
};
var btn = document.getElementById('btn');
btn.onclick = leo.say; // I'm BUTTON 

```


<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-91 onxxxx改变this指向.html">onxxxx改变this指向</a>

### 6.3 匿名函数调整this指向
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-92 匿名函数调整this指向.html">匿名函数调整this指向</a>
```
//  匿名函数调整this指向  代码清单5-92
var name = 'somebody';
var btn = document.getElementById('btn');
var leo = {
    name: 'leo',
    say: function() {
        alert("I'm " + this.name);
    }
};
leo.say(); // I'm leo
setTimeout(function() {leo.say()}, 1000); // I'm leo
setInterval(function() {leo.say()}, 1000); // I'm leo
btn.onclick = function() {leo.say() }; // I'm leo
setTimeout(function() {alert(this == window)}, 1000); // true
btn.onclick = function() {alert(this == btn)}; // true
```

### 6.4 call和apply调整this指向
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-93 call和apply调整this指向.html">call和apply调整this指向</a>

应对措施：
    使用匿名函数可以解决这个问题
        setTimeout、setInterval和"Dom.onxxx"改变的都是直接调用的函数里this的指向，其中setTimeout、setInterval将直接调用函数里的this指向window，"Dom.onxxx"将直接调用的函里的this指向DomNode。
        使用匿名函数将我们的处理函数封装起来，可以将我们的处理函数由直接调用变成匿名函数间接调用。
    使用call和apply函数来处理函数的this指向

```
//  call和apply调整this指向  代码清单5-93
var name = 'somebody';
var btn = document.getElementById('btn');
var leo = {
    name: 'leo',
    say: function() {
        alert("I'm " + this.name);
    }
};

leo.say.call(btn); // I'm BUTTON 
setTimeout(function() {leo.say.call(btn)}, 1000);  // I'm BUTTON 
setInterval(function() {leo.say.apply(btn)}, 1000); // I'm BUTTON 
btn.onclick = function() {leo.say.apply(btn)}; // I'm BUTTON 
```
在JavaScript中使用继承就需要用到call或apply函数。

### 6.5 将this指向的对象保存到变量
在改变this指向之前，将它指向的对象保存到一个变量中也是非常常用的方法
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-94 将this指向的对象保存到变量.html">将this指向的对象保存到变量</a>

```
//  将this指向的对象保存到变量  代码清单5-94
<input type="button" value="click me" id="btn" name="BUTTON" />
var name = 'somebody';
var leo = {
    name: 'leo',
    say: function() {
        alert("I'm " + this.name);
    },
    init: function() {
        var This = this;
        document.getElementById('btn').onclick = function() {
            This.say(); // I'm leo
            // alert('this' + this); // this[object HTMLInputElement]
            this.say(); // this.say is not a function
        }
    }
};

leo.init();
```
this关键字会改变指向，只要避开这个关键字就可得到一个稳定的引用。
Tab中，查看this在IE和Firefox下指向不同的对象，Firefox下顺利弹出对应DOM节点上的属性_index，可见Firefox下指向的是DOM节点，那IE下指向的是什么呢？window？
### 6.6 调试Bug
动手验证一下：
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-95 调试Bug.html">调试Bug</a>

```
//  调试Bug  代码清单5-95
GLOBAL.Event.on(tabMenus[i], trigger, function() {
    for(var j = 0; j < tabContents.length; j++) {
        tabContents[j].style.display = 'none';
    }
    // alert(this === window); // IE8-true，Firefox下false
    tabContents[this._index].style.display = 'block';
}
```
### 6.7 addEventListener和attachEvent和this指针

追踪代码可发现是GLOBAL.Event.on在封装addEventListener和attachEvent时引入的问题。
addEventListener和attachEvent除了传参不同，对this指针的处理也不同，如下：
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-96 addEventListener和attachEvent和this指针.html">addEventListener和attachEvent和this指针</a>
```
//  addEventListener和attachEvent和this指针  代码清单5-96
<input type="button" value="click me" id="btn" />
<script>
var btn = document.getElementById('btn');
if(btn.addEventListener) {
    btn.addEventListener('click', function() {
        alert(this.tagName); // INPUT
        alert(this === window); // false
    }, false);
}
else if(btn.attachEvent) {
    btn.attachEvent('onclick', function() {
        alert(this.tagName); // undefined
        alert(this === window); // true
    });
}
// else {
//     btn['on' + eventType] = function() {
//         alert(this.tagName);
//         alert(this === window);
//     };

</script>
```

### 6.8 加强addHandler函数的功能
所以我们可以对GLOBAL.Dom方法进一步强化，**允许显示地指定它的this指针方向**。如下：
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-97 加强addHandler函数的功能.html">加强addHandler函数的功能</a>
应对措施： 显示指定this指针指向，增加scope参数，用于设置handler中this指针指向，默认指向node节点
```
//  加强addHandler函数的功能  代码清单5-97

    // 添加事件（或者说监听事件）
    GLOBAL.Event.addHandler = function(node, eventType, handler, scope) {
        node = GLOBAL.Dom.get(node);
        scope = scope || node;
        if(node.addEventListener) {
            node.addEventListener(eventType, function() {handler.apply(scope, arguments)}, false);
        }
        else if(node.attachEvent) {
            node.attachEvent('on' + eventType, function() {handler.apply(scope, arguments)});
        }
        else {
            node['on' + eventType] = handler;
        }
    };

```
增加了scope参数，用于设置handler中的this指向，默认指向node节点。
修改GLOBAL.Event.addHandler方法之后，Tab在IE和Firefox下都可以正常运行了。


## 七、预留回调接口

对于Tab来说，存在一个菜单的激活事件，有时候我们可能需要监听菜单的激活事件，并相应地执行一些操作。
这个操作并不在主流程中执行，而是有菜单的激活事件来触发的，他可以由我们自己来定制，并且是可有可无的。
### 7.1 设置回调函数
对于这种需求，我们是通过设置回调函数来实现的
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-98 设置回调函数.html">设置回调函数</a>
```
//  设置回调函数  代码清单5-98
index4.css

 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu2">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>

<script>
var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
// 与DOM相关
GLOBAL.namespace("Dom");
GLOBAL.Dom.get = function(node) {
    node = typeof node === 'string' ? document.getElementById(node) : node;
    return node;
};
GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
    if(root) {
        root = GLOBAL.Dom.get(root);
    }
    else {
        root = document.body;
    }
    tag = tag || '*';
    var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
        arr = [];
    for(var i = 0, n = eles.length; i < n; i++) {
        for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
            if(k[j] == str) {
                arr.push(eles[i]);
                break;
            }
        }
    }
    return arr;
};  
// 添加class
GLOBAL.Dom.addClass = function(node, str) {
    if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
        node.className = node.className + ' ' + str;
    }
};
// 移除class
GLOBAL.Dom.removeClass = function(node, str) {
    node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
};

// 与Event相关
GLOBAL.namespace('Event');
// 添加事件（或者说监听事件）
GLOBAL.Event.addHandler = function(node, eventType, handler, scope) {
    node = GLOBAL.Dom.get(node);
    scope = scope || node;
    if(node.addEventListener) {
        node.addEventListener(eventType, function() {handler.apply(scope, arguments) }, false);
    }
    else if(node.attachEvent) {
        node.attachEvent('on' + eventType, function() {handler.apply(scope, arguments) });
    }
    else {
        node['on' + eventType] = handler;
    }
};



function setTab(root, currentClass, trigger, handler) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
        // 如果不传入激活类型，默认激活类型为点击
        trigger = trigger || "click";

    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i]._index = i;

        GLOBAL.Event.addHandler(tabMenus[i], trigger, function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }

            tabContents[this._index].style.display = 'block';

            // 设置样式
            if(currentClass) {
                var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
                if(currentMenu) {
                    GLOBAL.Dom.removeClass(currentMenu, currentClass);
                }
                GLOBAL.Dom.addClass(this, currentClass);
            }
            // 设置回调函数
            if(handler) {
                handler(this._index);
            }
        });
    }
}
var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
setTab(tabs[0], null, 'mouseover');
setTab(tabs[1], 'tab-currentMenu');
setTab(tabs[2], 'tab-currentMenu2', 'mouseover', function(index) {
    alert('您激活的是第' + (index + 1) + '个标签');
});
</script>
```
我们给setTab方法添加了handler参数，用于执行菜单激活事件的回调，handler是function类型，接收被激活菜单的索引作为参数。
添加回调的接口可以增加Tab的扩展性。


## 八、编程中的DRY规则
Tab有个常用的功能叫做自动切换，如果用户不去激活菜单，菜单本身也可以自动切换。
我们可以为Tab程序加上自动切换的功能，依据前面思路，将它做成可选的：如果在setTab函数的参数中，我们设置Tab可以自动切换，那么他就带自动切换功能，如果不设置，那么默认不带自动切换功能。
### 8.1 添加自动切换功能
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-99 添加自动切换功能.html">添加自动切换功能</a>
```
//  添加自动切换功能  代码清单5-99
// autoPlay, playTime
// index4.css


 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu2">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
// DOM相关
    GLOBAL.namespace("Dom");
    // 通过ID获取元素节点 node为DOM节点id或DOM节点本身
    GLOBAL.Dom.get = function(node) {
        node = typeof node === 'string' ? document.getElementById(node) : node;
        return node;
    };    
    GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
        if(root) {
            root = typeof root == 'string' ? document.getElementById(root) : root;
        }
        else {
            root = document.body;
        }
        tag = tag || '*';
        var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
            arr = [];
        for(var i = 0, n = eles.length; i < n; i++) {
            for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
                if(k[j] == str) {
                    arr.push(eles[i]);
                    break;
                }
            }
        }
        return arr;
    };  
    GLOBAL.Dom.addClass = function(node, str) {
        if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
            node.className = node.className + ' ' + str;
        }
    };
    GLOBAL.Dom.removeClass = function(node, str) {
        node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
    };
// Event相关
    GLOBAL.namespace('Event');
    // 添加事件（或者说监听事件）
    GLOBAL.Event.addHandler = function(node, eventType, handler, scope) {
        node = GLOBAL.Dom.get(node);
        scope = scope || node; // 显示指定this指针指向
        if(node.addEventListener) {
            node.addEventListener(eventType, function() {handler.apply(scope, arguments) }, false);
        }
        else if(node.attachEvent) {
            node.attachEvent('on' + eventType, function() {handler.apply(scope, arguments) });
        }
        else {
            node['on' + eventType] = handler;
        }
    };



function setTab(root, currentClass, trigger, handler, autoPlay, playTime) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
        // 如果不传入激活类型，默认激活类型为点击
        trigger = trigger || "click";
        playTime = playTime || 3000;
        var currentIndex = 0;
    function autoHandler() {
        currentIndex++;
        if(currentIndex >= tabMenus.length) {
            currentIndex = 0;
        }
        for(var i = 0; i < tabContents.length; i++) {
            tabContents[i].style.display = 'none';
        }
        tabContents[currentIndex].style.display = 'block';
        if(currentClass) {  
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
            if(currentMenu) {
                GLOBAL.Dom.removeClass(currentMenu, currentClass);
            }
            GLOBAL.Dom.addClass(tabMenus[currentIndex], currentClass);
        }
        if(handler) {
            handler(currentIndex);
        }
    }
    if(autoPlay) {
        setInterval(autoHandler, playTime);
    }
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i].index = i;
        GLOBAL.Event.on(tabMenus[i], trigger, function() {
            for(var j = 0; j < tabContents.length; j++) {
                tabContents[j].style.display = 'none';
            }
            // alert(this.index);
            // alert(this); // window
            tabContents[this.index].style.display = 'block';
            if(currentClass) {  
                // 如果有当前选中标签，则去掉“tab-currentMenu”
                var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
                if(currentMenu) {
                    GLOBAL.Dom.removeClass(currentMenu, currentClass);
                }
                GLOBAL.Dom.addClass(this, currentClass);
            }
            if(handler) {
                handler(this.index);
            }
            currentIndex = this.index;
        });
    }

}

var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
// 将Tab1和Tab3的标签激活方式改为mouseover
setTab(tabs[0], null, 'mouseover');
setTab(tabs[1], 'tab-currentMenu', null, null, true, 2000);
setTab(tabs[2], 'tab-currentMenu2', 'mouseover', function(index) {alert('您激活的是第' + (index + 1) + '个标签')});

```
我们给setTab函数内部添加了一个autoHandler函数用于处理自动切换，
通过传参autoPlay（布尔型）和playTime（数值型，单位为微妙），可以指定Tab是否启用自动切换功能。如启用，切换间隔为多少微妙（默认3000毫秒）。
功能虽然实现了，但程序存在问题，autoHandler函数内有很大一部分代码和addHandler代码重复。
### 8.2 重构代码，将相同代码提取出来
解决措施：只写一次，多处引用。
好处：一是可以提高代码的重用率，从而减小代码量；另一方面，如果重复的部分需要修改，只用修改一处，有利于提高代码的可维护性
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-100 重构代码，将相同代码提取出来.html">重构代码，将相同代码提取出来</a>
```
//  重构代码，将相同代码提取出来  代码清单5-100
var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
// DOM相关
    GLOBAL.namespace("Dom");
    // 通过ID获取元素节点 node为DOM节点id或DOM节点本身
    GLOBAL.Dom.get = function(node) {
        node = typeof node === 'string' ? document.getElementById(node) : node;
        return node;
    };   
    GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
        if(root) {
            root = typeof root == 'string' ? document.getElementById(root) : root;
        }
        else {
            root = document.body;
        }
        tag = tag || '*';
        var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
            arr = [];
        for(var i = 0, n = eles.length; i < n; i++) {
            for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
                if(k[j] == str) {
                    arr.push(eles[i]);
                    break;
                }
            }
        }
        return arr;
    };  
    GLOBAL.Dom.addClass = function(node, str) {
        if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
            node.className = node.className + ' ' + str;
        }
    };
    GLOBAL.Dom.removeClass = function(node, str) {
        node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
    };
// Event相关
    GLOBAL.namespace('Event');
    // 添加事件（或者说监听事件）
    GLOBAL.Event.addHandler = function(node, eventType, handler, scope) {
        node = GLOBAL.Dom.get(node);
        scope = scope || node; // 显示指定this指针指向
        if(node.addEventListener) {
            node.addEventListener(eventType, function() {handler.apply(scope, arguments) }, false);
        }
        else if(node.attachEvent) {
            node.attachEvent('on' + eventType, function() {handler.apply(scope, arguments) });
        }
        else {
            node['on' + eventType] = handler;
        }
    };



function setTab(root, currentClass, trigger, handler, autoPlay, playTime) {
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
        // 如果不传入激活类型，默认激活类型为点击
        trigger = trigger || "click";
        playTime = playTime || 3000;
        var currentIndex = 0;

    function showItem(n) {
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[n].style.display = 'block';
        if(currentClass) {  
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
            if(currentMenu) {
                GLOBAL.Dom.removeClass(currentMenu, currentClass);
            }
            GLOBAL.Dom.addClass(tabMenus[n], currentClass);
        }
        if(handler) {
            handler(n);
        }   
    }
    function autoHandler() {
        currentIndex++;
        if(currentIndex >= tabMenus.length) {
            currentIndex = 0;
        }
        showItem(currentIndex);
    }
    if(autoPlay) {
        setInterval(autoHandler, playTime);
    }
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i].index = i;
        GLOBAL.Event.on(tabMenus[i], trigger, function() {
            showItem(this.index);
            currentIndex = this.index;
        });
    }

}

var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
// 将Tab1和Tab3的标签激活方式改为mouseover
setTab(tabs[0], null, 'mouseover');
setTab(tabs[1], 'tab-currentMenu', null, null, true, 2000);
setTab(tabs[2], 'tab-currentMenu2', 'mouseover', function(index) {alert('您激活的是第' + (index + 1) + '个标签')});



```


## 九、用hash对象传参
程序好像已经不错了，setTab(tabs[1], 'tab-currentMenu', null, null, true, 2000);中两个null有点碍眼
因为不需要定制trigger和handler，但是又需要启动自动切换功能，所以我们不得不给trigger和handler传参null。
但如果以后我们还会再扩展setTab，是否需要用：setTab(tabs[1], 'tab-currentMenu', null, null, null, null, null, null true, 2000);调用它？不行，需要想想办法。
应对措施：最常见的方法是使用hash对象来传参

### 9.1 普通方式传参和用hash对象传参
比较一下用普通方式传参和用hash对象传参的区别：


<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-101 普通方式传参和用hash对象传参.html">普通方式传参和用hash对象传参</a>
```
//  普通方式传参和用hash对象传参  代码清单5-101

// 普通方式传参
function  test(a, b, c) {
    var oA = a || 1, oB = b || 2, oC = c || 3;
}
console.log(test(4, 5, 6));
console.log(test(null, 5, 6));
console.log(test(null, null, 6));


// 用hash对象传参
function test2(config) {
    var oA = config.a || 1, oB = config.b || 2, oC = config.c || 3;
}
console.log(test2({a: 4, b: 5, c: 6}));
console.log(test2({b: 7, c: 8}));
console.log(test2({c: 9}));
```
普通方式传参 参数如同数组，位置和顺序都非常重用，而用hash对象传参，参数的位置和顺序就不重要了。
类似于test(null, null, null, null, null, null, 'hello')这样的调用就可以改用test({str: 'hello'})
使用hash对象传参，可以提高函数调用的灵活性，也可以提高函数的扩展性

### 9.2 改用hash对象传参
setTab函数现在接受6个参数，除了root是必选的，其他5个全是可选的。将其修改一下，改用hash对象传参，如下：
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-102 改用hash对象传参.html">改用hash对象传参</a>
```
//  改用hash对象传参  代码清单5-102
index4.css

 <!-- 第一个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu">menu1-1</li>
        <li class="J_tab-menu">menu1-2</li>
        <li class="J_tab-menu underline">menu1-3</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content1-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content1-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" >content1-3</div>
    </div>
</div>
 <!-- 第二个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu">menu2-1</li>
        <li class="J_tab-menu">menu2-2</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content2-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content2-2</p><div>abc</div></div>
    </div>
</div>
 <!-- 第三个选项卡 -->
<div class="tab J_tab">
    <ul class="tab-menuWrapper">
        <li class="J_tab-menu tab-currentMenu2">menu3-1</li>
        <li class="J_tab-menu">menu3-2</li>
        <li class="J_tab-menu">menu3-3</li>
        <li class="J_tab-menu">menu3-4</li>
        <li class="J_tab-menu">menu3-5</li>
    </ul>
    <div class="tab-contentWrapper">
        <div class="J_tab-content"><div>content3-1 <ul><li>abc</li></ul></div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-2</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-3</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-4</p><div>abc</div></div>
        <div class="J_tab-content" style="display: none;" ><p>content3-5</p><div>abc</div></div>
    </div>
</div>


var GLOBAL = {};
GLOBAL.namespace = function(str) {
    var arr = str.split("."),
        o = GLOBAL;
    for(i = (arr[0] == "GLOBAL") ? 1 : 0; i < arr.length; i++) {
        o[arr[i]] = o[arr[i]] || {};
        o = o[arr[i]];
    }
};
// DOM相关
    GLOBAL.namespace("Dom");
    // 通过ID获取元素节点 node为DOM节点id或DOM节点本身
    GLOBAL.Dom.get = function(node) {
        node = typeof node === 'string' ? document.getElementById(node) : node;
        return node;
    };
    GLOBAL.Dom.getElementsByClassName = function(str, root, tag) {
        if(root) {
            root = typeof root == 'string' ? document.getElementById(root) : root;
        }
        else {
            root = document.body;
        }
        tag = tag || '*';
        var eles = root.getElementsByTagName(tag), // 获取父容器下所有标签
            arr = [];
        for(var i = 0, n = eles.length; i < n; i++) {
            for(var j = 0, k = eles[i].className.split(' '), l = k.length; j < l; j++) {
                if(k[j] == str) {
                    arr.push(eles[i]);
                    break;
                }
            }
        }
        return arr;
    };  
    GLOBAL.Dom.addClass = function(node, str) {
        if(!new RegExp("(^|\\s+)"+str).test(node.className)) {
            node.className = node.className + ' ' + str;
        }
    };
    GLOBAL.Dom.removeClass = function(node, str) {
        node.className = node.className.replace(new RegExp("(^|\\s+)" + str), '');
    };
// Event相关
    GLOBAL.namespace('Event');
    // 添加事件（或者说监听事件）
    GLOBAL.Event.addHandler = function(node, eventType, handler, scope) {
        node = GLOBAL.Dom.get(node);
        scope = scope || node; // 显示指定this指针指向
        if(node.addEventListener) {
            node.addEventListener(eventType, function() {handler.apply(scope, arguments) }, false);
        }
        else if(node.attachEvent) {
            node.attachEvent('on' + eventType, function() {handler.apply(scope, arguments) });
        }
        else {
            node['on' + eventType] = handler;
        }
    };

function setTab(config) {
    var root = config.root;
    var currentClass = config.currentClass;
    var trigger = config.trigger;
    var handler = config.handler;
    var autoPlay = config.autoPlay;
    var playTime = config.playTime || 3000;
    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    var tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', root),
        tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', root);
        // 如果不传入激活类型，默认激活类型为点击
        trigger = trigger || "click";
        playTime = playTime || 3000;
        var currentIndex = 0;

    function showItem(n) {
        for(var j = 0; j < tabContents.length; j++) {
            tabContents[j].style.display = 'none';
        }
        tabContents[n].style.display = 'block';
        if(currentClass) {  
            // 如果有当前选中标签，则去掉“tab-currentMenu”
            var currentMenu = GLOBAL.Dom.getElementsByClassName(currentClass, root)[0];
            if(currentMenu) {
                GLOBAL.Dom.removeClass(currentMenu, currentClass);
            }
            GLOBAL.Dom.addClass(tabMenus[n], currentClass);
        }
        if(handler) {
            handler(n);
        }   
    }
    function autoHandler() {
        currentIndex++;
        if(currentIndex >= tabMenus.length) {
            currentIndex = 0;
        }
        showItem(currentIndex);
    }
    if(autoPlay) {
        setInterval(autoHandler, playTime);
    }
    for(var i = 0; i < tabMenus.length; i++) {
        tabMenus[i].index = i;
        GLOBAL.Event.on(tabMenus[i], trigger, function() {
            showItem(this.index);
            currentIndex = this.index;
        });
    }

}
var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
// 将Tab1和Tab3的标签激活方式改为mouseover
setTab({root: tabs[0], trigger:'mouseover'});
setTab({root: tabs[1], currentClass: 'tab-currentMenu', autoPlay: true, playTime: 2000});
setTab({root: tabs[2], currentClass: 'tab-currentMenu2', trigger: 'mouseover', handler: function(index) {alert('您激活的是第' + (index + 1) + '个标签')}});

```

### 9.3 用面向对象方式重构Tab
下面改用面向对象的方式来写Tab
<a href="http://p03fjrkvd.bkt.clouddn.com/github/2017/1129/code5-136 用面向对象方式重构Tab.html">用面向对象方式重构Tab</a>
```
function Tab(config) {
    this._root = config.root;
    this._currentClass = config.currentClass;
    var trigger = config.trigger || 'click';
    this._handler = config.handler;
    var autoPlay = config.autoPlay;
    var playTime = config.playTime || 3000;

    // 获得tabMenu和tabContent的DOM节点，并保存在变量中
    this._tabMenus = GLOBAL.Dom.getElementsByClassName('J_tab-menu', this._root),
        this._tabContents = GLOBAL.Dom.getElementsByClassName('J_tab-content', this._root);

    this.currentIndex = 0;
    var This = this;
    if(autoPlay) {
        setInterval(function() {This._autoHandler}, playTime);
    }
    //遍历数组，让 tabMenu 监听 click 事件
    for(var i = 0; i < this._tabMenus.length; i++) {
        this._tabMenus[i]._index = i;
        GLOBAL.Event.addHandler(this._tabMenus[i], trigger, function() {
            This.showItem(this._index);
            this.currentIndex = this._index;
        });
    }
}
Tab.prototype = {
    showItem: function(n) {
        for(var i = 0; i < this._tabContents.length; i++) {
            this._tabContents[i].style.display = 'none';
        }
        this._tabContents[n].style.display = 'block';  
        // 设置样式
        if(this._currentClass) {
            var currentMenu = GLOBAL.Dom.getElementsByClassName(this._currentClass, this._root)[0];
            if(currentMenu) {
                GLOBAL.Dom.removeClass(currentMenu, this._currentClass);
            }
            GLOBAL.Dom.addClass(this._tabMenus[n], this._currentClass);
        }
        // 设置回调函数
        if(this._handler) {
            this._handler(n);
        }  
    },
    _autoHandler: function() {
        this.currentIndex++;
        if(this.currentIndex >= this._tabMenus.length) {
            this.currentIndex = 0;
        }
        this.showItem(this.currentIndex);           
    }
}

var tabs = GLOBAL.Dom.getElementsByClassName('J_tab');
new Tab({root: tabs[0], trigger: 'mouseover'});
new Tab({root: tabs[1], currentClass: 'tab-currentMenu', autoPlay: true, playTime: 5000});
new Tab({root: tabs[2], currentClass: 'tab-currentMenu2', trigger: 'mouseover', handler: function(index) {
    alert('您激活的是第' + (index + 1) + '个标签');
}});
```

